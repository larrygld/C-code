/*
 66.砝码组合 (15分)
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
用天平称重时，我们希望用尽可能少的砝码组合称出尽可能多的重量。
如果只有5个砝码，重量分别是1，3，9，27，81。
则它们可以组合称出1到121之间任意整数重量（砝码允许放在左右两个盘中）。
本题目要求编程实现：对用户输入的重量(1~121)，
给出砝码组合方案（用加减式表示，减代表砝码放在物品盘）。
例如：
输入：
5
输出：
9-3-1 
输入：
19
输出：
27-9+1
要求程序输出的组合总是大数在前小数在后。
输入描述
用户输入的重量(1~121)，
输出描述
给出砝码组合方案（用加减式表示，减代表砝码放在物品盘）。
输入样例
19
输出样例
27-9+1
*/


#include <stdio.h>

int n, v[5], s[5] = {1, 3, 9, 27, 81};

/*
	n: 要求被组合的数
	v: 记录该砝码是否加入
	s: 记录砝码重量
	m: 当前砝码是否加减进行的位置
	sum：记录运行时累加的重量 
*/

void fun(int m, int sum){
	
	if(sum == n){
		int i = 4;
		
		while(true){
			if(v[i] == 1){
				printf("%d", s[i]);
				break;
			}
			i--;
		}
		
		for(int j = i - 1; j >= 0; j--){
			if(v[j] == 1){
				printf("+%d", s[j]);
			}
			if(v[j] == -1){
				printf("-%d", s[j]);
			}
		}
		return;	
	}
	
	if(m >= 5){	//递归结束条件 
		return;
	}
	
	//不加 标注为 0
	fun(m + 1, sum);
	//加 标注为 1
	v[m] = 1;
	fun(m + 1, sum + s[m]);
	v[m] = 0;	//先假设加入此砝码可以组合到所需重量，如果运行完无法达到，则重新置为0，下面减同理 
	//减 标注为 -1
	v[m] = -1;
	fun(m + 1, sum - s[m]);
	v[m] = 0;
	 
	
}


int main(){
	
	scanf("%d", &n);
	fun(0, 0);  //从0开始，从0开始累积重量 
//	printf("\n");
//	for(int i = 0; i < 5; i++){
//		printf("%d ", v[i]);
//	}
	return 0;
}

 



